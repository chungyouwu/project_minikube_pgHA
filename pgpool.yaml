#pgpool
apiVersion: v1  
kind: ConfigMap
metadata:
  name: pgpool-config
  labels:
    name: pgpool-config
data:
  pgpool.conf: |-
    listen_addresses = '*'
    port = 9999
    socket_dir = '/var/run/pgpool'
    pcp_listen_addresses = '*'
    pcp_port = 9898
    pcp_socket_dir = '/var/run/pgpool'
    backend_hostname0 = 'postgres-svc'
    backend_port0 = 5432
    backend_weight0 = 1
    backend_flag0 = 'ALLOW_TO_FAILOVER'
    backend_hostname1 = 'replica1-svc'
    backend_port1 = 5432
    backend_weight1 = 2
    backend_flag1 = 'ALLOW_TO_FAILOVER'
    backend_hostname2 = 'replica2-svc'
    backend_port2 = 5432
    backend_weight2 = 2
    backend_flag2 = 'ALLOW_TO_FAILOVER'

    sr_check_period = 10
    sr_check_user = 'postgres'
    sr_check_password = '0000'
    sr_check_database = 'postgres'
    health_check_timeout = '20'
    health_check_user = 'postgres'
    health_check_password = '0000'
    health_check_period = 10
    backend_clustering_mode = 'streaming_replication'
    num_init_children = 32
    max_pool = 4
    child_life_time = 300
    child_max_connections = 0
    connection_life_time = 0
    client_idle_limit = 0
    connection_cache = on
    load_balance_mode = on
    ssl = on
    enable_pool_hba = on
    failover_on_backend_error = on
    log_min_messages = warning
    failover_command = '/test/failover.sh "%d" "%h" "%p" "%D" "%m" "%M" "%H" "%P" "%r" "%R"'
    follow_primary_command = '/test/follow_primary.sh "%d" "%h" "%p" "%D" "%m" "%M" "%H" "%P" "%r" "%R"'

  # failover_command 參數必須加上雙引號, 否則會無法正確傳遞參數給 failover.sh
  # follow_primary_command: Specifies a user command to run after failover on the primary node failover
  # If we use 3 PostgreSQL servers, we need to specify follow_primary_command to run after failover on the primary node failover. 
  # In case of two PostgreSQL servers, follow_primary_command setting is not necessary.


  # If pool_hba.conf isn't configured, Pgpool-II will automatically generate it.
  # Note that to use pool_hba.conf you must set enable_pool_hba = on.
  #pool_hba.conf: |-
  #  local      all         all                          trust
  #  hostssl    all         all         0.0.0.0/0        scram-sha-256i

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: failover-script
data:  # 必須提供 export PGPASSWORD='0000' 以下 psql 命令才能執行
  failover.sh: |
    #!/bin/bash

    failed_node_id=$1
    failed_host_name=$2
    failed_port=$3
    failed_db_cluster=$4
    new_main_id=$5
    old_main_id=$6
    new_main_host_name=$7
    old_primary_node_id=$8
    new_main_port_number=$9
    new_main_db_cluster=${10}

    failed_node_id_trimmed=$(echo "$failed_node_id" | sed 's/^ *//;s/ *$//')
    old_main_id_trimmed=$(echo "$old_main_id" | sed 's/^ *//;s/ *$//')

    log="/test/failover.log"    

    touch $log
    if [ $? -ne 0 ]; then
      echo "Cannot write to log file: $log"
      exit 1
    fi 

    date >> $log
    echo "failed_node_id: $failed_node_id" >> $log
    echo "failed_host_name: $failed_host_name" >> $log
    echo "failed_port: $failed_port" >> $log
    echo "failed_db_cluster: $failed_db_cluster" >> $log
    echo "new_main_id: $new_main_id" >> $log
    echo "old_main_id: $old_main_id" >> $log
    echo "new_main_host_name: $new_main_host_name" >> $log
    echo "old_primary_node_id: $old_primary_node_id" >> $log
    echo "new_main_port_number: $new_main_port_number" >> $log
    echo "new_main_db_cluster: $new_main_db_cluster" >> $log

    export PGPASSWORD='0000'

    if [ a"$old_main_id_trimmed" = a"$failed_node_id_trimmed" ];then        
        echo "promoting replica DB " >> $log
        psql -h "$new_main_host_name" -p $new_main_port_number -U postgres -c "SELECT pg_promote(true);" >> $log

        echo "start checking promoting result" >> $log
        psql -h "$new_main_host_name" -p $new_main_port_number -U postgres -c "SELECT pg_is_in_recovery();" >> $log

        echo "change primary_conninfo in old replica DB(new master DB)" >> $log
        psql -h "$new_main_host_name" -p $new_main_port_number -U postgres -c "ALTER SYSTEM SET primary_conninfo = 'host=replica1-svc port=5432 user=postgres password=''0000''';" >> $log

        echo "reloading new master DB" >> $log
        psql -h "$new_main_host_name" -p $new_main_port_number -U postgres -c "SELECT pg_reload_conf();"
        sleep 3
    else
        echo "failed_node_id not equal to old_primary_node_id" >> $log
           
    fi

    echo "DEBUG INFO:" >> $log
    echo "Parameters received:" >> $log
    echo "$@" >> $log


---
apiVersion: v1
kind: ConfigMap
metadata:
  name: followprimary-script
data:  # https://git.postgresql.org/gitweb/?p=pgpool2.git;a=blob_plain;f=src/sample/scripts/follow_primary.sh.sample;hb=refs/heads/V4_4_STABLE
  follow_primary.sh: |
    #!/bin/bash
    # This script is run after failover_command to synchronize the Standby with the new Primary.
    # First try pg_rewind. If pg_rewind failed, use pg_basebackup.
    
    log="/test/follow_primary.log"

    touch $log
    if [ $? -ne 0 ]; then
      echo "Cannot write to log file: $log"
      exit 1
    fi     
    
    set -o xtrace
    
    # Special values:
    # 1)  %d = node id
    # 2)  %h = hostname
    # 3)  %p = port number
    # 4)  %D = node database cluster path
    # 5)  %m = new primary node id
    # 6)  %M = old main node id
    # 7)  %H = new primary node hostname
    # 8)  %P = old primary node id
    # 9)  %r = new primary port number
    # 10) %R = new primary database cluster path
    # 11) %N = old primary node hostname
    # 12) %S = old primary node port number
    # 13) %% = '%' character

    NODE_ID="$1"
    NODE_HOST="$2"
    NODE_PORT="$3"
    NODE_PGDATA="/var/lib/postgresql/data"
    NEW_PRIMARY_NODE_ID="$5"
    OLD_MAIN_NODE_ID="$6"
    NEW_PRIMARY_NODE_HOST="$7"
    OLD_PRIMARY_NODE_ID="$8"
    NEW_PRIMARY_NODE_PORT="$9"
    NEW_PRIMARY_NODE_PGDATA="/var/lib/postgresql/data"

    RECOVERYCONF=${NODE_PGDATA}/myrecovery.conf
    PGHOME="/usr/libexec/postgresql15/"

    date >> $log
    echo "node_id: $NODE_ID" >> $log
    echo "node_host: $NODE_HOST" >> $log
    echo "node_port: $NODE_PORT" >> $log
    echo "node_pgdata: $NODE_PGDATA" >> $log
    echo "new_primary_node_id: $NEW_PRIMARY_NODE_ID" >> $log
    echo "old_main_node_id: $OLD_MAIN_NODE_ID" >> $log
    echo "new_primary_node_host: $NEW_PRIMARY_NODE_HOST" >> $log
    echo "old_primary_node_id: $OLD_PRIMARY_NODE_ID" >> $log
    echo "new_main_node_port: $NEW_PRIMARY_NODE_PORT" >> $log
    echo "new_primary_node_pgdata: $NEW_PRIMARY_NODE_PGDATA" >> $log
    echo "myrecovery.conf: $RECOVERYCONF" >> $log
    echo "pghome: $PGHOME" >> $log


    NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    API_SERVER="https://kubernetes.default.svc"
    POD_NAME="replica2-0"
    POD_IP=$(curl -sSk -H "Authorization: Bearer $TOKEN" ${API_SERVER}/api/v1/namespaces/${NAMESPACE}/pods/${POD_NAME} | grep -o '"podIP": "[^"]*' | sed 's/"podIP": "//')
    
    echo "namespace: ${NAMESPACE}" >> $log
    echo "api_server: ${API_SERVER}" >> $log    
    echo "pod_ip: ${POD_IP}" >> $log


    # Check the connection status of Standby
      pg_isready -h ${NODE_HOST} -p ${NODE_PORT} > /dev/null
      if [ $? -ne 0 ]; then
          echo "follow_primary.sh: node_id=${NODE_ID} is not running. skipping follow primary command" >> $log
          exit 0
      fi

    # Test passwordless SSH
      sshpass -p 0000 ssh -p 22 -o StrictHostKeyChecking=no root@${NEW_PRIMARY_NODE_HOST} ls /tmp > /dev/null    
      if [ $? -ne 0 ]; then
          echo "follow_main.sh: passwordless SSH to root@${NEW_PRIMARY_NODE_HOST} failed. Please setup passwordless SSH." >> $log
          exit 1
      fi

    
    # Run checkpoint command to update control file before running pg_rewind
      psql -h ${NEW_PRIMARY_NODE_HOST} -p ${NEW_PRIMARY_NODE_PORT} -U postgres -d postgres -c "checkpoint;"
      echo "follow_primary.sh: pg_rewind for node ${NODE_ID}" >> $log

    # GO
      sshpass -p 0000 ssh -p 22 -o StrictHostKeyChecking=no root@${NEW_PRIMARY_NODE_HOST} "
      
        set -o errexit      
        pg_ctl -w -m f -D ${NODE_PGDATA} stop      
        pg_rewind -D ${NODE_PGDATA} --source-server=\"user=postgres password=0000 host=${NEW_PRIMARY_NODE_HOST} port=${NEW_PRIMARY_NODE_PORT} dbname=postgres\"      
        cat > ${RECOVERYCONF} << EOT
        primary_conninfo = 'host=${NEW_PRIMARY_NODE_HOST} port=${NEW_PRIMARY_NODE_PORT} user=${REPLUSER} application_name=${NODE_HOST} passfile=''/var/lib/pgsql/.pgpass'''
        recovery_target_timeline = 'latest'     
        EOT

        sed -i -e \"\\\$ainclude_if_exists = '$(echo ${RECOVERYCONF} | sed -e 's/\//\\\//g')'\" \
               -e \"/^include_if_exists = '$(echo ${RECOVERYCONF} | sed -e 's/\//\\\//g')'/d\" ${NODE_PGDATA}/postgresql.conf
        touch ${NODE_PGDATA}/standby.signal

        pg_ctl -l /dev/null -w -D ${NODE_PGDATA} start
      "

    # If start Standby successfully, Run pcp_attact_node to attach Standby node to Pgpool-II.
      if [ $? -eq 0 ]; then
        pcp_attach_node -w -h localhost -U $PCP_USER -p ${PCP_PORT} -n ${NODE_ID}
        echo "pcp_attach_node success"
        if [ $? -ne 0 ]; then
            echo "ERROR: follow_primary.sh: end: pcp_attach_node failed" >> $log
            exit 1
        fi
      fi
    
    echo "follow_primary.sh: end: follow primary command is completed successfully" >> $log
    exit 0



---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: pgpool
spec:
  serviceName: pgpool
  replicas: 1
  selector:
    matchLabels:
      app: pgpool
  template:
    metadata:
      labels:
        app: pgpool
    spec:
      securityContext: # 需要使用root權限才能執行 lifecycle 裡面的命令 
        runAsUser: 0  # 這會以 root 用戶運行容器
        fsGroup: 0    # 這會設置文件系統的組 ID 為 0
      
      containers:
      - name: pgpool
        image: poolssh
        imagePullPolicy: IfNotPresent
        lifecycle:
          postStart:
            exec:
              command:  # 需要先將由comfigmap掛載到/script/內的檔案複製出來, 否則該掛載資料夾下無法賦予執行權限(指向性檔案)
                - /bin/bash
                - -c
                - |
                  mkdir /test/;
                  cp /script/failover.sh /test/;
                  cp /script/follow_primary.sh /test/;
                  chmod 777 /test/failover.sh
                  chmod 777 /test/follow_primary.sh
        env:
        - name: POSTGRES_USERNAME  #在postgres-secret變數為 POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_USER

        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD

        - name: PGPOOL_PASSWORD_ENCRYPTION_METHOD
          value: "scram-sha-256"

        - name: PGPOOL_ENABLE_POOL_PASSWD
          value: "true"

        - name: PGPOOL_SKIP_PASSWORD_ENCRYPTION
          value: "false"

        # The following settings are not required when not using the Pgpool-II PCP command.
        # To enable the following settings, you must define a secret that stores the PCP user's
        # username and password. 使用方法: 
        # 1. kubectl exec -it pgpool-0 -- bash  
        # 2. /opt/pgpool-II/etc$ /opt/pgpool-II/bin/pcp_node_count -h localhost -p 9898 -U postgres
        - name: PGPOOL_PCP_USER
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: PGPOOL_PCP_USER 

        - name: PGPOOL_PCP_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: PGPOOL_PCP_PASSWORD

        volumeMounts:
        - name: pgpool-config
          mountPath: /config

        - name: failover-script
          mountPath: /script/failover.sh
          subPath: failover.sh

        - name: followprimary-script 
          mountPath: /script/follow_primary.sh
          subPath: follow_primary.sh
          
        #- name: pgpool-tls
        #  mountPath: /config/tls

      volumes:
      - name: pgpool-config
        configMap:  #在環境變數中沒指定但有很多設定要應用，則將comfigmap 整個掛到容器讓它應用
          name: pgpool-config
      
      - name: failover-script
        configMap:
          name: failover-script

      - name: followprimary-script 
        configMap:
          name: followprimary-script
      # Configure your own TLS certificate.
      # If not set, Pgpool-II will automatically generate the TLS certificate if ssl = on.
      #- name: pgpool-tls
      #  secret:
      #    secretName: pgpool-tls


---
apiVersion: v1
kind: Service
metadata:
  name: pgpool-svc
spec:
  type: NodePort  # 用 minikube service pgpool-svc --url 開放給本機連線
  selector:
    app: pgpool
  ports:
  - name: pgpool-port
    protocol: TCP
    port: 9999
    targetPort: 9999